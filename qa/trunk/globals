#!/usr/bin/expect
#
# Purpose: Establish global state information for SLURM test suite
#
global scancel scontrol sinfo squeue srun

#
# Specify location of slurm executable files
# These may be just the command names or full pathnames
#
set scancel	"scancel"
set scontrol	"scontrol"
set sinfo	"sinfo"
set squeue	"squeue"
set srun	"srun"

#
# Specify locations of other executable files used
# Only the shell names (e.g. bin_bash) must be full pathnames
#
set bin_awk 	"awk"
set bin_bash	"/bin/bash"
set bin_cat	"cat"
set bin_chmod	"chmod"
set bin_echo	"echo"
set bin_env	"env"
set bin_id	"id"
set bin_hostname "hostname"
set bin_kill	"kill"
set bin_killall	"killall"
set bin_make	"make"
set bin_ps	"ps"
set bin_pwd	"pwd"
set bin_rm	"rm"
set bin_sleep   "sleep"
set bin_sort    "sort"
set bin_touch   "touch"
set bin_wc	"wc"

#
# Let the commands complete without expect timing out waiting for a 
# response. Single node jobs submitted to the default partition should 
# be initiated within this number of seconds.
# for interactive slurm jobs: set timeout $max_job_delay
#
set max_job_delay 60

#
# Files must be propogated between nodes within this number of seconds.
# The delay may be due to NFS.
#
set max_file_delay 60

#
# Specify the maximum number of tasks to use in the stress tests.
#
set max_stress_tasks 4

# Other common variables
set alpha          "\[a-zA-Z\]+"
set alpha_cap      "\[A-Z\]+"
set alpha_numeric  "\[a-zA-Z0-9\]+"
set end_of_line    "\[\r\n\]"
set number         "\[0-9\]+"


################################################################
#
# Proc: cancel_job
#
# Purpose:  Cancel the specified job
#
# Returns: A non-zero return code indicates a failure.
#
# Input: job_id  -- The SLURM job id of a job we want to cancel.
#
################################################################

proc cancel_job { job_id } {
	global scancel

	send_user "cancelling $job_id\n"
	exec $scancel $job_id
	sleep 1
	return [wait_for_job $job_id "DONE"]
}


################################################################
#
# Proc: get_line_cnt
#
# Purpose:  Return size of the specified file
#
# Returns: Number of lines in the specified file.
#
# Input: file_name  -- Name of file to inspect.
#
################################################################
proc get_line_cnt { file_name } {
	global bin_wc number
	set lines 0
	spawn $bin_wc -l $file_name
	expect {
		-re "($number) " {
			set lines $expect_out(1,string)
			exp_continue
		}
		eof {
		}
	}
	return $lines
}

################################################################
#
# Proc: kill_srun
#
# Purpose:  Issue three "killall -INT srun" commands
#
# Returns: A non-zero return code indicates a failure.
#
################################################################

proc kill_srun {  } {
	global bin_killall

	exec $bin_killall -INT srun
	exec $bin_killall -INT srun
	exec $bin_killall -INT srun
	return 0
}


################################################################
#
# Proc: print_header
#
# Purpose:  Print header with test ID
#
# Input: job_id   -- The SLURM job id of a job we want to cancel.
#
################################################################

proc print_header { test_id } {

	send_user "============================================\n"
	send_user "TEST: $test_id\n"
}


################################################################
#
# Proc: wait_for_file
#
# Purpose:  Wait for the specified file to exist. This delay 
# provides time for NFS files to be propogated. The 
#
# Returns: A non-zero return code indicates a failure.
#
# Input: file_name   -- Name of the file to wait for.
#
################################################################

proc wait_for_file { file_name } {
	global max_file_delay

	for {set my_delay 0} {$my_delay <= $max_file_delay} {incr my_delay} {
		if {$my_delay > 0} {
			sleep 1
		}
		if [file exists $file_name] {
			return 0
		}
	}
	send_user "\nFAILURE: Timeout waiting for file $file_name\n"
	return 1
}


################################################################
#
# Proc: wait_for_job
#
# Purpose:  Wait for a previously submitted SLURM job to reach 
# the desired state, exponential back-off 1 to 10 seconds
#
# Returns: A non-zero return code indicates a failure.
#
# Input: job_id   -- The SLURM job id of a job we want to
#                    wait for.
#        state    -- The state you want the job to attain before
#                    returning.  Currently supports:
#                        DONE any terminated state
#                        RUNNING job is running
#
# NOTE: We sleep for two seconds before replying that a job is 
# done to give time for I/O completion (stdout/stderr files)
#
################################################################

proc wait_for_job { job_id state } {
	global max_job_delay
	global scontrol
	set is_done     0
	set is_running  0
	set sleep_time  1

	while { 1 == 1 } {
		spawn -noecho $scontrol -o show job $job_id
		expect {
			-re "Job \[0-9]* not found" {
				set is_done 1 
				exp_continue
			}
			-re "JobState=COMPLETE" {
				set is_done 1 
				exp_continue
			}
			-re "JobState=FAILED" {
				set is_done 1 
				exp_continue
			}
			-re "JobState=TIMEOUT" {
				set is_done 1 
				exp_continue
			}
			-re "JobState=NODE_FAIL" {
				set is_done 1 
				exp_continue
			}
			-re "JobState=RUNNING" {
				set is_running 1 
				exp_continue
			}
			timeout {
				send_user "\nFAILURE: scontrol not responding\n"
				return 1
			}
			eof {
			}
		}
	
		if {[string compare $state "DONE"] == 0    && $is_done == 1 } {
			sleep  2
			return 0
		}
		if {[string compare $state "RUNNING"] == 0 && $is_running == 1 } {
			return 0
		}
		if {                                          $is_done == 1 } {
			return 1
		}

		sleep $sleep_time
		set sleep_time  [expr $sleep_time * 2]
		if { $sleep_time > 10 } {
			set sleep_time 10
		}
	}
}
