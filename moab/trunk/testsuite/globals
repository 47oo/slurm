#!/usr/bin/expect
############################################################################
# Purpose: Establish global state information for Moab test suite
#
# To define site-specific state information, set the values in a file
# named 'globals.local'. Those values will override any specified here.
# for example:
#
# $ cat globals.local
# set moab_dir      "/usr/local"
# set max_job_delay 300
#
############################################################################
# Copyright (C) 2002-2006 The Regents of the University of California.
# Produced at Lawrence Livermore National Laboratory (cf, DISCLAIMER).
# Written by Morris Jette <jette1@llnl.gov>
############################################################################

global canceljob checkjob msub showq

# Conditional set.  Only set variable if variable does not yet exist.
proc cset {name value} {
	if {![uplevel 1 info exists $name]} {
		upvar $name tmp
		set tmp $value
	}
}

if [file exists globals.local] {
	source globals.local
}

#
# Specify the moab install directory.
# Used to locate binaries, libraries, and header files.
#
cset moab_dir    "/usr/local"
cset canceljob   "${moab_dir}/bin/canceljob"
cset checkjob    "${moab_dir}/bin/checkjob"
cset mshow       "${moab_dir}/bin/mshow"
cset msub        "${moab_dir}/bin/msub"
cset showq       "${moab_dir}/bin/showq"

cset lcrm_dir    "/usr/local"
cset pstat       "${lcrm_dir}/bin/pstat"
cset psub        "${lcrm_dir}/bin/psub"

#
# Specify locations of other executable files used
# Only the shell names (e.g. bin_bash) must be full pathnames
#
cset bin_bash    [exec which bash]

# Pattern to match your shell prompt
cset prompt {(%|#|\$|\]) *$}

#
# Let the commands complete without expect timing out waiting for a 
# response. Single node jobs submitted to the default partition should 
# be initiated within this number of seconds.
#
cset max_job_delay 120

#
# Files must be propogated between nodes within this number of seconds.
# The delay may be due to NFS.
#
cset max_file_delay 120

#
# The error message that the "sleep" command prints when we run "sleep aaa".
#
cset sleep_error_message "(invalid time interval)|(bad character in argument)"

# Other common variables
set alpha                "\[a-zA-Z\]+"
set alpha_cap            "\[A-Z\]+"
set alpha_numeric        "\[a-zA-Z0-9\]+"
set alpha_numeric_under  "\[a-zA-Z0-9_\]+"
set alpha_under          "\[A-Z_\]+"
set end_of_line          "\[\r\n\]"
set number               "\[0-9\]+"
set float                "\[0-9\]+\\.?\[0-9\]+"

################################################################
#
# Proc: cancel_job
#
# Purpose:  Cancel the specified job
#
# Returns: A non-zero return code indicates a failure.
#
# Input: job_id  -- The Moab job id of a job we want to cancel.
#
################################################################

proc cancel_job { job_id } {
	global canceljob

	send_user "cancelling $job_id\n"
	catch {exec $canceljob $job_id}
	exec sleep 1
	return [wait_for_job $job_id "DONE"]
}


################################################################
#
# Proc: get_line_cnt
#
# Purpose:  Return size of the specified file
#
# Returns: Number of lines in the specified file.
#
# Input: file_name  -- Name of file to inspect.
#
################################################################
proc get_line_cnt { file_name } {
	global bin_wc number
	set lines 0
	spawn $bin_wc -l $file_name
	expect {
		-re "($number) " {
			set lines $expect_out(1,string)
			exp_continue
		}
		eof {
			wait
		}
	}
	return $lines
}

################################################################
#
# Proc: slow_kill
#
# Purpose:  Kill a process slowly, first trying SIGINT, pausing for
#       a second, then sending SIGKILL.
#
# Returns: A non-zero return code indicates a failure.
#
################################################################

proc slow_kill { pid } {
	catch {exec kill -INT $pid}
	catch {exec kill -INT $pid}
	sleep  1
	catch {exec kill -KILL $pid}

	return 0
}

################################################################
#
# Proc: print_header
#
# Purpose:  Print header with test ID
#
# Input: job_id   -- The SLURM job id of a job we want to cancel.
#
################################################################

proc print_header { test_id } {

	send_user "============================================\n"
	send_user "TEST: $test_id\n"
}

################################################################
#
# Proc: print_date
#
# Purpose:  Print the time and date
#
################################################################

proc print_date { } {
	spawn date
	expect {
		eof {
			wait
		}
	}
}

################################################################
#
# Proc: wait_for_file
#
# Purpose:  Wait for the specified file to exist. This delay 
# provides time for NFS files to be propogated. The 
#
# Returns: A non-zero return code indicates a failure.
#
# Input: file_name   -- Name of the file to wait for.
#
################################################################

proc wait_for_file { file_name } {
	global max_file_delay

	for {set my_delay 0} {$my_delay <= $max_file_delay} {incr my_delay} {
		if {$my_delay > 0} {
			exec sleep 1
		}
		if [file exists $file_name] {
#			Add small delay for I/O buffering
			exec sleep 10
			return 0
		}
	}
	send_user "\nFAILURE: Timeout waiting for file $file_name\n"
	return 1
}


################################################################
#
# Proc: wait_for_job
#
# Purpose:  Wait for a previously submitted Moab job to reach 
# the desired state, exponential back-off 1 to 10 seconds
#
# Returns: A non-zero return code indicates a failure.
#
# Input: job_id   -- The Moab job id of a job we want to
#                    wait for.
#        desired_state -- The state you want the job to attain before
#                         returning.  Currently supports:
#                            DONE any terminated state
#                            RUNNING job is running
#
# NOTE: We sleep for two seconds before replying that a job is 
# done to give time for I/O completion (stdout/stderr files)
#
################################################################

proc wait_for_job { job_id desired_state } {
	global checkjob

	# First verify that desired_state is supported
	switch $desired_state {
		"DONE" {}
		"RUNNING" {}
		default {
			send_user "Unsupported desired state: $desired_state\n"
			return 1
		}
	}

	set sleep_time  1
	while 1 {
		set fd [open "|$checkjob -A $job_id"]
		gets $fd line
		catch {close $fd}
		if {[regexp {STATE=(\w+);} $line foo state] != 1} {
			set state "NOT_FOUND"
		}

		switch $state {
			"NOT_FOUND" -
			"Completed" -
			"Removed" {
				if {[string compare $desired_state "DONE"] == 0} {
					send_user "Job $job_id is DONE\n"
					sleep 2
					return 0
				}
				if {[string compare $desired_state "RUNNING"] == 0} {
					send_user "Job $job_id is $state, "
					send_user "but we wanted RUNNING\n"
				}
				return 1
			}
			"Running" {
				if {[string compare $desired_state "RUNNING"] == 0} {
					send_user "Job $job_id is RUNNING\n"
					return 0
				}
				send_user "Job $job_id is in state $state, "
				send_user "desire $desired_state\n"
			}
			default {
				send_user "Job $job_id is in state $state, "
				send_user "desire $desired_state\n"
			}
		}

		exec sleep $sleep_time
		set sleep_time  [expr $sleep_time * 2]
		if { $sleep_time > 10 } {
			set sleep_time 10
		}
	}
}

################################################################
#
# Proc: test_aix
#
# Purpose: Determine if the system is AIX
#
# Returns 1 if the system is AIX, 0 otherwise
#
################################################################

proc test_aix {} {
	set fd [open "|uname"]
	gets $fd line
	close $fd
	if {[string compare $line AIX] == 0} {
		return 1
	} else {
		return 0
	}
}

################################################################
#
# Proc: make_bash_script
#
# Purpose: Create a bash script of name "script_name", and
#          make the body of the script "script_contents".
#          make_bash_script removes the file if it already exists,
#          then generates the #! line, and then dumps "script_contents"
#          to the file.  Finally, it makes certain that the script
#          is executable.
#
# Returns: Nothing.
#
# Input: script_name - file name for the bash script
#        script_contents - body of the script, not including the
#                          initial #! line.
#
################################################################

proc make_bash_script { script_name script_contents } {
	global bin_bash

	file delete $script_name
	set fd [open $script_name "w"]
	puts $fd "#!$bin_bash"
	puts $fd $script_contents
	close $fd
	exec chmod 700 $script_name
}

################################################################
#
# Proc: name_job_count
#
# Return the count of running or pending jobs with the given name
#
################################################################

proc name_job_count { prog_name } {
	set matches 0
	spawn squeue
	expect {
		-re "$prog_name" {
			incr matches
			exp_continue
		}
		eof {
			wait
		}
	}
	return $matches
}

################################################################
#
# Proc: test_bluegene
#
# Purpose: Determine if the system is a bluegene system
#
# Returns 1 if the system is a bluegene, 0 otherwise
#
################################################################

proc test_bluegene { } {
	global bin_bash

	log_user 0
	set bluegene 0
	spawn scontrol show config
	expect {
		-re "select/bluegene" {
			set bluegene 1
			exp_continue
		}
		timeout {
			send_user "\nFAILURE: scontrol not responding\n"
		}
		eof {
			wait
		}
	}
	log_user 1

	return $bluegene
}

################################################################
#
# Proc: default_partition
#
# Purpose: Use scontrol to determine the name of the default partition
#
# Returns: Name of the current default partition
#
################################################################

proc default_partition {} {

	set name ""
	set fd [open "|scontrol --all --oneliner show partition"]
	while {[gets $fd line] != -1} {
		if {[regexp {^PartitionName=(\w+).*Default=YES} $line frag name]
				== 1} {
			break
		}
	}
	catch {close $fd}

	if {[string length $name] == 0} {
		send_user "ERROR: could not identify the default partition\n"
	}

	return $name
}
